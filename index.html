<!DOCTYPE html>
<html>

<head>
    <title>MJpeg Stream</title>
    <script src="assets/js/jquery-3.2.1.slim.min.js"></script>
</head>

<body>
    <h1>MJpeg Stream</h1>
    <div id="mjpeg_player" style="width:500px; border: solid 1px blue; height: 400px;"></div>
    <img id="my-img" style="width:500px; border: solid 1px blue; height: 400px;" />
    <p id="response"></p>
     
    <script>
        let run = true;
        //Using jQuery for simplicity
        const  src = 'http://localhost:8080/mjpeg';
        const encoder = new TextEncoder();
        const decoder = new TextDecoder(encoder.encoding);
        const LAST_HEADER = "Access-Control-Allow-Origin: *\r\n\r\n";
        const BOUNDARY = "\r\n--MJPEGStreamerboundary\r\n";
        let _temp = null;
        
        let _incompleteBytes = [];

        fetch(src).then((response) => {
            const reader = response.body.getReader();
            const stream = new ReadableStream({
                start(controller) {
                console.log('status code:', response.status);
                function push() {
                    reader.read().then(({ done, value }) => {
                    //
                        if (run == false) return;
                    //
                        process(value);
                        // document.getElementById("response").innerHTML = 
                        //     string.substring(0, 200)
                        //     + "<br/> LENGTH:"
                        //     + _rawImgArray.length + " vs Expected: " + contentLength + " Match : " + lengthMatch
                        //     + "<br/> 50 element first"
                        //     + JSON.stringify(_rawImgArray.splice(0, 50))
                        //     + "<br/> 50 element first"
                        //     + JSON.stringify(_rawImgArray.splice(_rawImgArray.length - 50, 50))
                        //     + "<br/>"
                        //     + string.substring(strlen-BOUNDARY.length - 2, strlen);
                        push();
                    });
                };

                push();
                }
            });

            return new Response(stream, { headers: { "Content-Type": "text/html" } });
        });

        function isValidResponseString(string)
        {
            if (!string.toLowerCase().startsWith("mime") || !string.endsWith(BOUNDARY) || string.split(LAST_HEADER).length != 2)
            {
                return false;
            }
            return true;
        }

        /**
         * @param {Uint8Array} value
         */
        function process(value)
        {
            const string = decoder.decode(value);
            let stringSplit = string.split(LAST_HEADER);
            if (!isValidResponseString(string))
            {
                processInCompleteResponse(Array.from(value), string);
                return;
            }

            const _rawImgArray = extractImageBytes(Array.from(value), string);
            // console.log("Valid response");
            
            let splitted = new String(string).split(LAST_HEADER);
            
            let contentLength = splitted[0].trim().split("Content-Length:")[1].trim();
            let lengthMatch = _rawImgArray.length == parseInt(contentLength);
            document.getElementById('my-img').src = URL.createObjectURL(new Blob( [_temp], { type: 'image/jpeg' }));
        }

        /**
         * @param {Array} completeBytes
         * @param {String} completeString
         */
        function extractImageBytes(completeBytes, completeString)
        {
            const strlen            = completeString.length;
            const imageByteArray    = Array.from(completeBytes);
            const stringSplit       = completeString.split(LAST_HEADER); // expected length = 2
            const removedCount      = stringSplit[0].length + LAST_HEADER.length;
            const tailRemoveCount   = BOUNDARY.length + 2;

            // trim from starting index
            imageByteArray.splice(0, removedCount);
            // trim end
            imageByteArray.splice(imageByteArray.length - tailRemoveCount + 2, tailRemoveCount );

            // currently starts with [255, 216,.... & ends with ...., 255, 217]
            if ( imageByteArray[0] == 255 && imageByteArray[1] == 216)
            {
                _temp = new Uint8Array(imageByteArray);
            }
            
            return imageByteArray;
        }

        /**
         * @param  {Array} bytes
         * @param string {String} string
         */
        function processInCompleteResponse(bytes, string)
        {
            
            const splitBoundary =  string.split(BOUNDARY);
            if (string.trim().toLowerCase().startsWith("mime"))
            {
                // console.log("XXX >>MIME. splitBoundary.length: ", splitBoundary.length);
                if (splitBoundary.length == 2)
                {
                    let tailRemoveCount = splitBoundary[1].length + 2;
                    _incompleteBytes = bytes.splice(bytes.length - tailRemoveCount + 2, tailRemoveCount)

                    string = splitBoundary[0];
                    const bytesPartOne = bytes.splice(0, string.length);
                    if (isValidResponseString(string))
                    {
                        // console.log("oooooooooooooooo become valid");
                        process(new Uint8Array(bytesPartOne));
                    }
                    else
                    {
                        console.log("!!!!!!!!!!!!!!!! still invalid");
                    }
                    return;
                }
                else
                {
                    _incompleteBytes = bytes;
                    return;
                }
            }
            else
            {
                // console.log("not start with mime");
                if (_incompleteBytes!=null && string.endsWith(BOUNDARY))
                {
                    // console.log("XXX <<BOUNDARY");
                    for (let i = 0; i < bytes.length; i++) {
                        _incompleteBytes.push(bytes[i]);
                    }
                    let uint8Arr = new Uint8Array(_incompleteBytes);
                    const string = decoder.decode(uint8Arr);
                    if (isValidResponseString(string))
                    {
                        // console.log("+ + + + + + + +  become valid");
                        process(uint8Arr);
                    }
                    else
                    {
                        console.log("______________ still invalid");
                    }
                    _incompleteBytes = null;
                }
                else
                {
                    console.log("NOT END WITH BOUNDARY");
                    console.log("splitBoundary :", splitBoundary.length);
                }
            }
        }
    </script>
</body>

</html>
